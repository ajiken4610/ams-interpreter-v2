# AjiMarkupScript

## 動機

昔、文字の装飾をする規格として、`AjiML`というものを設計したのですが、自分的にいまいちだったので、新しい規格を作るべく、`AjiMarkupScript`、略して`AMS`を設計しました。  
　設計するにあたって、`AjiML`のいまいちな点を挙げました。

### 構文に一貫性がない

AjiML では、それぞれの種類の文を表すのにそれぞれ異なる記号(`!`,`#`,`$`,`&`,`[`,`{`)を使っていたため、似た機能に対して異なる記号を用いる必要がある箇所がいくらか存在しました。  
　そこで、AMS では、使用する記号は「`;`,`:`,`{`,`}`,`\`」の 5 つとし、あらゆる場合で同じ記号の使い方をするようにしました。

### 書きずらい

AjiML では、上記の通りキーボードの上のほうにあるキーをたくさん使うので、シフトキーを押しすぎて小指が壊れます。  
　そこで、AMS では、基本的にキーボードの右側にあるキーをそのまま押せるようになっています。  
　 ▼AjiML(上)と AMS(下)の使用するキーの比較
![AjiMLとAMSのキーボード使用の比較](https://drive.google.com/uc?id=11HJ5tAQp85_wojD1zCN70C_uB5qMrnvv "上：AjiML、下：AMS")

### 拡張性がない

AjiML では、`$`記号で変数宣言が可能でしたが、変数に入れることができるのは文字の装飾タイプだけで、それ以外は全く入れることができませんでした。  
　これは、AjiML がマークアップ言語として設計されたための制約でした。(もはや意味がなかった制約事項。)  
　そこで、AMS では、存在するあらゆるオブジェクトを変数に入れることができるようにしました。

## 予約記号、予約語

AMS では、これらの記号が予約されています。

-   「`\`,`{`,`}`,`:`,`;`」
-   「`import`,`export`」

また、AMS では、変数名に`.`を含むことはできません。(名前空間と区別がつかなくなるため。)

## 文法

AMS は階層構造となっている。
階層構造の仕様は以下のようになっている。

-   1 つのプログラムは、Paragraph として定義される。
-   Paragraph は、0 つ以上の Sentence の配列である。
-   Sentence は 0 つ以上の Word のチェーンである。
-   Word は以下のオブジェクトの総称である。
    -   Variable
    -   Invoker
    -   Text
    -   Paragraph
-   Variable は、変数を表す。
-   Invoker は、最大で 1 つの Word を含む。

### Paragraph

Paragraph は、`{}`でくくって定義する。  
Paragraph に対して呼び出しが行われると、配列の each のように Paragraph のそれぞれの要素に対して破壊的に呼び出しが行われる。  
`{}`内で`;`を用いて Sentence を分ける。

### Sentence

Sentence に対して呼び出しが行われると、保持している Word が連鎖的に呼び出され、その結果が返る。  
例えば、以下のような Sentence があったとき、  
`AA:BB\CC`
AA に BB が引数として与えられて呼び出され、その結果にたいして\CC を引数として呼び出され、その結果が帰ってくる。

### Variable

変数は`\(変数名)`として表され、`\(変数名)`は参照を返す。`\(変数名)`に呼び出しを行うと値が帰ってくる。Variable を引数アリで呼び出すと、引数.invokeFinal()が変数に入る。

AMS の変数には以下の 2 つのバリエーションがある。

1. ローカル変数  
   ローカル変数は、ブロックスコープで利用できる変数。
2. 名前空間付き変数
   名前空間付き変数は、`名前空間.変数名`として表される。 `import`宣言を用いれば、名前空間は省略できる。AMS の基本構文は`ams.grammer`名前空間に属している。  
   import は、最後にされたものから優先的に使用される。

### Invoker

引数が 1 つの Word で表せるときに使う。  
例えば、`\AA:BB`とあったら、変数`AA`に Text"BB"が入る。
