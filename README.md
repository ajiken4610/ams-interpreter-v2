# AjiMarkupScript

## 動機

昔、文字の装飾をする規格として、`AjiML`というものを設計したのですが、自分的にいまいちだったので、新しい規格を作るべく、`AjiMarkupScript`、略して`AMS`を設計しました。  
　設計するにあたって、`AjiML`のいまいちな点を挙げました。

### 構文に一貫性がない

AjiML では、それぞれの種類の文を表すのにそれぞれ異なる記号(`!`,`#`,`$`,`&`,`[`,`{`)を使っていたため、似た機能に対して異なる記号を用いる必要がある箇所がいくらか存在しました。  
　そこで、AMS では、使用する記号は「`;`,`:`,`{`,`}`,`\`」の 5 つとし、あらゆる場合で同じ記号の使い方をするようにしました。

### 書きずらい

AjiML では、上記の通りキーボードの上のほうにあるキーをたくさん使うので、シフトキーを押しすぎて小指が壊れます。  
　そこで、AMS では、基本的にキーボードの右側にあるキーをそのまま押せるようになっています。  
　 ▼AjiML(上)と AMS(下)の使用するキーの比較
![AjiMLとAMSのキーボード使用の比較](https://drive.google.com/uc?id=11HJ5tAQp85_wojD1zCN70C_uB5qMrnvv "上：AjiML、下：AMS")

### 拡張性がない

AjiML では、`$`記号で変数宣言が可能でしたが、変数に入れることができるのは文字の装飾タイプだけで、それ以外は全く入れることができませんでした。  
　これは、AjiML がマークアップ言語として設計されたための制約でした。(もはや意味がなかった制約事項。)  
　そこで、AMS では、存在するあらゆるオブジェクトを変数に入れることができるようにしました。
## 予約記号、予約語
AMSでは、これらの記号が予約されています。

- 「`\`,`{`,`}`,`:`,`;`」
- 「`import`,`export`」

## 文法
AMSは階層構造となっている。
階層構造の仕様は以下のようになっている。

- 1つのプログラムは、Paragraphとして定義される。
- Paragraphは、0つ以上のSentenceの配列である。
- Sentenceは0つ以上のWordのチェーンである。
- Wordは以下のオブジェクトの総称である。
    - Variable
    - Invoker
    - Text
    - Paragraph
- Variableは、変数を表す。
- Invokerは、最大で1つのWordを含む。

### Paragraph  
Paragraphは、`{}`でくくって定義する。    
Paragraphに対して呼び出しが行われると、配列のeachのようにParagraphのそれぞれの要素に対して破壊的に呼び出しが行われる。  
`{}`内で`;`を用いてSentenceを分ける。

### Sentence
Sentenceに対して呼び出しが行われると、保持しているWordが連鎖的に呼び出され、その結果が返る。  
例えば、以下のようなSentenceがあったとき、  
`AA:BB\CC`
AAにBBが引数として与えられて呼び出され、その結果にたいして\CCを引数として呼び出され、その結果が帰ってくる。  

### Variable
変数は`\(変数名)`として表され、`\(変数名)`は参照を返す。`\(変数名)`に呼び出しを行うと値が帰ってくる。Variableを引数アリで呼び出すと、引数.invokeFinal()が変数に入る。  

### Invoker
引数が1つのWordで表せるときに使う。  
例えば、`\AA:BB`とあったら、変数`AA`にText"BB"が入る。
